/*
 * first generated by Xtext
 */
package jp.hishidama.xtext.dmdl_editor.ui.outline;

import java.util.ArrayList;
import java.util.HashSet;
import java.util.List;
import java.util.Set;

import jp.hishidama.xtext.dmdl_editor.dmdl.Attribute;
import jp.hishidama.xtext.dmdl_editor.dmdl.AttributeList;
import jp.hishidama.xtext.dmdl_editor.dmdl.DmdlPackage;
import jp.hishidama.xtext.dmdl_editor.dmdl.Grouping;
import jp.hishidama.xtext.dmdl_editor.dmdl.JoinExpression;
import jp.hishidama.xtext.dmdl_editor.dmdl.JoinTerm;
import jp.hishidama.xtext.dmdl_editor.dmdl.ModelDefinition;
import jp.hishidama.xtext.dmdl_editor.dmdl.ModelFolding;
import jp.hishidama.xtext.dmdl_editor.dmdl.ModelMapping;
import jp.hishidama.xtext.dmdl_editor.dmdl.ModelReference;
import jp.hishidama.xtext.dmdl_editor.dmdl.ModelUtil;
import jp.hishidama.xtext.dmdl_editor.dmdl.Property;
import jp.hishidama.xtext.dmdl_editor.dmdl.PropertyDefinition;
import jp.hishidama.xtext.dmdl_editor.dmdl.PropertyFolding;
import jp.hishidama.xtext.dmdl_editor.dmdl.PropertyMapping;
import jp.hishidama.xtext.dmdl_editor.dmdl.PropertyUtil;
import jp.hishidama.xtext.dmdl_editor.dmdl.RecordExpression;
import jp.hishidama.xtext.dmdl_editor.dmdl.RecordTerm;
import jp.hishidama.xtext.dmdl_editor.dmdl.SummarizeExpression;
import jp.hishidama.xtext.dmdl_editor.dmdl.SummarizeTerm;
import jp.hishidama.xtext.dmdl_editor.dmdl.Type;
import jp.hishidama.xtext.dmdl_editor.ui.labeling.DMDLImages;

import org.eclipse.emf.common.util.EList;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EStructuralFeature;
import org.eclipse.jface.viewers.StyledString;
import org.eclipse.swt.graphics.Image;
import org.eclipse.xtext.nodemodel.INode;
import org.eclipse.xtext.nodemodel.util.NodeModelUtils;
import org.eclipse.xtext.ui.editor.outline.IOutlineNode;
import org.eclipse.xtext.ui.editor.outline.impl.DefaultOutlineTreeProvider;
import org.eclipse.xtext.ui.editor.outline.impl.DocumentRootNode;
import org.eclipse.xtext.ui.editor.outline.impl.EStructuralFeatureNode;
import org.eclipse.xtext.util.TextRegion;

/**
 * Customization of the default outline structure.
 * 
 * see http://www.eclipse.org/Xtext/documentation.html#outline
 */
public class DMDLOutlineTreeProvider extends DefaultOutlineTreeProvider {

	@Override
	protected void _createChildren(DocumentRootNode parentNode, EObject modelElement) {
		for (EObject childElement : modelElement.eContents()) {
			createNode(parentNode, childElement);
		}
	}

	protected void _createChildren(IOutlineNode parentNode, ModelDefinition model) {
		if (model == null) {
			return;
		}
		AttributeList attributes = model.getAttributes();
		if (attributes != null) {
			createNode(parentNode, attributes);
			// for (Attribute attr : attributes.getAttributes()) {
			// createNode(parentNode, attr);
			// }
		}

		EObject rhs = model.getRhs();
		if (rhs instanceof RecordExpression) {
			createRecordModelChildren(parentNode, (RecordExpression) rhs);
			return;
		}
		if (rhs instanceof JoinExpression) {
			createJoinModelChildren(parentNode, (JoinExpression) rhs);
			return;
		}
		if (rhs instanceof SummarizeExpression) {
			createSummarizeModelChildren(parentNode, (SummarizeExpression) rhs);
			return;
		}

		if (rhs != null) {
			throw new IllegalStateException("rhs=" + rhs);
		}
	}

	private void createRecordModelChildren(IOutlineNode parentNode, RecordExpression rhs) {
		EList<RecordTerm> terms = rhs.getTerms();
		for (RecordTerm term : terms) {
			ModelReference ref = term.getReference();
			if (ref != null) {
				if (!ModelUtil.recursiveModel(term.eContainer(), ref.getName())) {
					createNode(parentNode, ref);
				}
			} else {
				EList<PropertyDefinition> properties = term.getProperties();
				for (PropertyDefinition p : properties) {
					createNode(parentNode, p);
				}
			}
		}
	}

	private void createJoinModelChildren(IOutlineNode parentNode, JoinExpression rhs) {
		EList<JoinTerm> terms = rhs.getTerms();
		Set<String> set = new HashSet<String>();
		List<EObject> list = new ArrayList<EObject>();
		List<Grouping> glist = new ArrayList<Grouping>();
		for (JoinTerm term : terms) {
			ModelMapping mapping = term.getMapping();
			if (mapping != null) {
				EList<PropertyMapping> properties = mapping.getMappings();
				for (PropertyMapping p : properties) {
					String key = p.getName();
					if (!set.contains(key)) {
						set.add(key);
						list.add(p);
					}
				}
			} else {
				ModelReference ref = term.getReference();
				if (ref != null) {
					if (!ModelUtil.recursiveModel(term.eContainer(), ref.getName())) {
						list.add(ref);
					}
				}
			}
			Grouping group = term.getGrouping();
			if (group != null) {
				glist.add(group);
			}
		}
		for (EObject p : list) {
			createNode(parentNode, p);
		}
		for (Grouping g : glist) {
			createNode(parentNode, g);
		}
	}

	private void createSummarizeModelChildren(IOutlineNode parentNode, SummarizeExpression rhs) {
		EList<SummarizeTerm> terms = rhs.getTerms();
		for (SummarizeTerm term : terms) {
			ModelFolding folding = term.getFolding();
			if (folding != null) {
				EList<PropertyFolding> properties = folding.getFoldings();
				for (PropertyFolding p : properties) {
					createNode(parentNode, p);
				}
			}
			Grouping group = term.getGrouping();
			if (group != null) {
				createNode(parentNode, group);
			}
		}
	}

	protected void _createChildren(IOutlineNode parentNode, ModelReference ref) {
		_createChildren(parentNode, ref.getName());
	}

	protected void _createChildren(IOutlineNode parentNode, Grouping group) {
		EStructuralFeature feature = DmdlPackage.Literals.GROUPING__NAME;
		Image image = DMDLImages.getPropertyImage();

		List<INode> list = NodeModelUtils.findNodesForFeature(group, feature);
		for (INode node : list) {
			String text = NodeModelUtils.getTokenText(node).trim();
			EStructuralFeatureNode snode = createEStructuralFeatureNode(parentNode, group, feature, image, text, true);
			TextRegion region = new TextRegion(node.getOffset(), node.getLength());
			snode.setTextRegion(region);
		}
	}

	/*
	 * isLeaf
	 */

	protected boolean _isLeaf(Attribute modelElement) {
		return true;
	}

	protected boolean _isLeaf(ModelReference modelElement) {
		return false;
	}

	protected boolean _isLeaf(Grouping modelElement) {
		return false;
	}

	/*
	 * text
	 */

	protected Object _text(ModelReference ref) {
		return _text(ref.getName());
	}

	protected Object _text(Property p) {
		String name = p.getName();
		Type type = PropertyUtil.getResolvedDataType(p);
		if (type != null) {
			StyledString ss = newStyledString(name);
			ss.append(" : " + type, StyledString.DECORATIONS_STYLER);
			return ss;
		}
		return name;
	}

	private StyledString newStyledString(String text) {
		return new StyledString((text != null) ? text : "<undifined>");
	}
}
