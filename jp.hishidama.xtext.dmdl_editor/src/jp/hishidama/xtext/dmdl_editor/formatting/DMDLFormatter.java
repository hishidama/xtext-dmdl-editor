/*
 * first generated by Xtext
 */
package jp.hishidama.xtext.dmdl_editor.formatting;

import jp.hishidama.xtext.dmdl_editor.services.DMDLGrammarAccess;

import org.eclipse.emf.ecore.EObject;
import org.eclipse.xtext.Keyword;
import org.eclipse.xtext.formatting.IIndentationInformation;
import org.eclipse.xtext.formatting.impl.AbstractDeclarativeFormatter;
import org.eclipse.xtext.formatting.impl.FormattingConfig;
import org.eclipse.xtext.parsetree.reconstr.IHiddenTokenHelper;
import org.eclipse.xtext.parsetree.reconstr.ITokenStream;
import org.eclipse.xtext.service.AbstractElementFinder;
import org.eclipse.xtext.util.Pair;
import org.eclipse.xtext.xbase.lib.Extension;

import com.google.inject.Inject;

/**
 * This class contains custom formatting description.
 * 
 * see : http://www.eclipse.org/Xtext/documentation.html#formatting on how and when to use it
 * 
 * Also see {@link org.eclipse.xtext.xtext.XtextFormattingTokenSerializer} as an example
 */
public class DMDLFormatter extends AbstractDeclarativeFormatter {
	@Inject
	@Extension
	private DMDLGrammarAccess grammarAccess;

	@Inject
	private IHiddenTokenHelper hiddenTokenHelper;

	@Override
	protected void configureFormatting(FormattingConfig c) {
		DMDLGrammarAccess f = grammarAccess;

		c.setAutoLinewrap(120);

		// 丸括弧
		for (Pair<Keyword, Keyword> pair : f.findKeywordPairs("(", ")")) {
			c.setLinewrap().after(pair.getFirst()); // 開き括弧の直後は改行する
			c.setLinewrap().before(pair.getSecond()); // 閉じ括弧の直前は改行する
			// 引数の個数に応じた改行有無はDMDLTokenStreamで実装

			c.setIndentation(pair.getFirst(), pair.getSecond());
		}
		// 波括弧
		curlyBrace(c, f.getRecordTermAccess());
		curlyBrace(c, f.getModelMappingAccess());
		curlyBrace(c, f.getModelFoldingAccess());

		// カンマ
		for (Keyword comma : f.findKeywords(",")) {
			c.setNoSpace().before(comma); // 直前は詰める
		}
		// セミコロン
		for (Keyword semicolon : f.findKeywords(";")) {
			c.setNoSpace().before(semicolon); // 直前は詰める
			c.setLinewrap().after(semicolon); // 直後は改行する
		}
		// @
		for (Keyword atmark : f.findKeywords("@")) {
			c.setNoSpace().after(atmark); // 直後は詰める
		}
		// ピリオド
		for (Keyword period : f.findKeywords(".")) {
			c.setNoSpace().around(period); // 両側とも詰める
		}

		// descriptionの直後は改行する
		c.setLinewrap().after(f.getDescriptionRule());

		// attribute
		c.setNoSpace().before(f.getAttributeElementBlockAccess().getLeftParenthesisKeyword_1()); // (の直前は詰める
		c.setLinewrap().after(f.getAttributeElementListAccess().getCommaKeyword_1_0()); // ,の直後は改行する
		c.setLinewrap().after(f.getAttributeRule()); // 直後は改行する

		// プロパティーの前は1行空ける
		c.setLinewrap(2).before(f.getPropertyDefinitionRule());
		c.setLinewrap(2).before(f.getPropertyMappingRule());
		c.setLinewrap(2).before(f.getPropertyFoldingRule());

		// joinedの+の直前は改行する
		c.setLinewrap().before(f.getJoinExpressionAccess().getPlusSignKeyword_1_0());

		// モデル定義の後は1行空ける
		c.setLinewrap(2).after(f.getModelDefinitionRule());

		// コメント
		c.setLinewrap(0, 1, 2).before(f.getSL_COMMENTRule());
		c.setLinewrap(0, 1, 2).before(f.getML_COMMENTRule());
		c.setLinewrap(0, 1, 1).after(f.getML_COMMENTRule());
	}

	private void curlyBrace(FormattingConfig c, AbstractElementFinder rule) {
		for (Pair<Keyword, Keyword> pair : rule.findKeywordPairs("{", "}")) {
			c.setLinewrap().after(pair.getFirst());

			// インデントを二重（スペース4つ）にする
			c.setIndentation(pair.getFirst(), pair.getSecond());
			c.setIndentation(pair.getFirst(), pair.getSecond());
		}
	}

	@Override
	protected IIndentationInformation getIndentInfo() {
		return new IIndentationInformation() {

			public String getIndentString() {
				return "  "; // 1つのインデントはスペース2つ
			}
		};
	}

	@Override
	public ITokenStream createFormatterStream(String indent, ITokenStream out, boolean preserveWhitespaces) {
		return super.createFormatterStream(indent, wrapStream(out), preserveWhitespaces);
	}

	@Override
	public ITokenStream createFormatterStream(EObject context, String indent, ITokenStream out,
			boolean preserveWhitespaces) {
		return super.createFormatterStream(context, indent, wrapStream(out), preserveWhitespaces);
	}

	protected ITokenStream wrapStream(ITokenStream out) {
		return new DMDLTokenStream(out, hiddenTokenHelper);
	}
}
